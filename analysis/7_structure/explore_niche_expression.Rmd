---
title: "Niche gene expression"
author: "Ricardo Ramirez"
date: "5/5/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Introduction

By performing an integration of spots of all slides, I aimed to define classes per spot that represent a niche (or a cell community). My intuition is that spots that are similar share compositions or functions throughout samples. This comes from my assumption that the heart tissue is a mosaic and the idea is to identify the color and size of the tiles.

```{r setup, include=FALSE}
library(scater)
library(tidyverse)
library(philentropy)
library(corrplot)
library(edgeR)
library(ComplexHeatmap)
library(uwot)
library(lme4)
library(lmerTest)
library(fgsea)
source("./analysis/utils/pseudobulk_utils.R")
```

## Getting the pseudobulk expression profile of niches

```{r}
niche_gex_obj <- readRDS("./processed_visium/integration/ps_integrated_slides_niches.rds")[[1]]

meta_data <- colData(niche_gex_obj$gex) %>%
  as.data.frame() %>%
  dplyr::rename(sample = orig.ident,
         niche = opt_clust_integrated) %>%
  dplyr::mutate(niche = paste0("niche_", niche)) %>%
  dplyr::mutate(col_id = paste0(sample, ".", niche))

niche_gex <- assay(niche_gex_obj$gex)
colnames(niche_gex) <- meta_data$col_id
```

First, we need to filter all niche expression profiles coming from less than 30 spots

```{r}
low_q_profiles <- which(meta_data$ncells < 30)

niche_gex <- niche_gex[, -low_q_profiles]
meta_data <- meta_data[-low_q_profiles, ]
```

Then we filter all niches that are not represented by many samples

```{r}
table(meta_data$niche)
```

```{r}
niche_names <- table(meta_data$niche)
low_q_niches <- names(niche_names)[which(niche_names < 2)]
low_q_niches <- which(meta_data$niche %in% low_q_niches)
niche_gex <- niche_gex[, -low_q_niches]
meta_data <- meta_data[-low_q_niches, ]
```

```{r}
niche_gex_cpm <- niche_gex %>%
  edgeR_filtering(expression_matrix = . , min.count = 50, 
                  min.prop = 0, min.total.count = 0) %>%
  cpm_norm(expression_matrix = .)
```

## PCA

```{r}
ilr_pcs <- prcomp(x = t(niche_gex_cpm),center = T,scale. = T)
ilr_pcs <- ilr_pcs$x %>%
  as.data.frame() %>%
  rownames_to_column("col_id")
```

```{r}
ilr_pcs %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = niche)) +
      geom_point(size = 2) +
      theme_classic()
```

We expect a huge batch effect driven by the sample:

```{r}
ilr_pcs %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = sample)) +
      geom_point(size = 2) +
      theme_classic()
```

## UMAP

```{r}
gex_umap <- umap(t(niche_gex_cpm)) %>%
  as.data.frame()

colnames(gex_umap) <- c("UMAP1", "UMAP2")

rownames(gex_umap) <- meta_data$col_id 

gex_umap %>%
  rownames_to_column("col_id") %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = UMAP1, y = UMAP2, 
             color = sample)) +
      geom_point(size = 2) +
      theme_classic()
```

```{r}
gex_umap %>%
  rownames_to_column("col_id") %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = UMAP1, y = UMAP2, 
             color = niche)) +
      geom_point(size = 2) +
      theme_classic()
```

## Alternative: Jensen Shannon divergences

```{r}
niche_gex_counts <- niche_gex %>%
  edgeR_filtering(expression_matrix = . , min.count = 50, min.prop = 0, min.total.count = 0)


jsd_dist <- as.data.frame(philentropy::JSD(t(niche_gex_counts),
                                           est.prob = "empirical"))
  
rownames(jsd_dist) = colnames(jsd_dist) <- colnames(niche_gex_counts)
  
# Make it distance ----------------------------------
jsd_dist <- jsd_dist ** (1/2)

mds_data <- cmdscale(dist(jsd_dist), eig=TRUE, k=2)$points

mds_data %>%
  as.data.frame() %>%
  rownames_to_column("col_id") %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = V1, y = V2, 
             color = sample)) +
      geom_point(size = 2) +
      theme_classic()
```

## What if we standardize each gene within each sample?

The vsmc niche is the only one that separates, with some of the immune clusters following

```{r}
sample_ids <- set_names(meta_data$sample %>% unique())

std_niche_gex_cpm <- map(sample_ids, function(s_id) {
  
  niche_gex_cpm[,which(meta_data$sample == s_id)] %>%
    t() %>%
    scale() %>%
    t()
  
})

std_niche_gex_cpm <- reduce(std_niche_gex_cpm, cbind)
```

```{r}
ilr_pcs <- prcomp(x = t(std_niche_gex_cpm),center = T,scale. = T)

ilr_pcs <- ilr_pcs$x %>%
  as.data.frame() %>%
  rownames_to_column("col_id")

ilr_pcs %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = niche)) +
      geom_point(size = 2) +
      theme_classic()
```

## Using mixed models?

```{r}
niche_gex_cpm_long <- niche_gex_cpm %>%
  as.data.frame() %>%
  rownames_to_column("gene") %>%
  pivot_longer(-gene, names_to = "col_id", values_to = "expr") %>%
  left_join(meta_data, by = "col_id")
```

### Run differential expression models using the samples as random effects

```{r, warning = F, message=F, eval=F}
niche_gex_cpm_long <- niche_gex_cpm_long %>%
  group_by(gene) %>%
  nest() %>%
  mutate(mxeff_models = map(data, function(x) {
    niches <- x$niche %>% unique() %>% set_names()
    
    map(niches, function(niche_id) { 
      
      niche_data <- x %>% 
        dplyr::mutate(niche = ifelse(niche == niche_id, 
                                     "test_niche",
                                     "reference_niche")) %>%
        dplyr::mutate(niche = factor(niche, 
                                     levels = c("reference_niche",
                                                "test_niche")))
      
      fit <- lmerTest::lmer(expr ~ niche + (1 | sample), data = niche_data)
      
      }) %>% enframe()
    
  })) 

test_resuls <- niche_gex_cpm_long %>%
  dplyr::select(gene, mxeff_models) %>%
  unnest() %>%
  mutate(model_coefficients = map(value, function(x) {
    mem_res <- summary(x)
    mem_res$coefficients  %>%
      as.data.frame() %>% 
      rownames_to_column("term") %>% 
      pivot_longer(-term)
  })) %>%
  mutate(anova_pval = map(value, function(x) {
    aov_res <- anova(x)
    aov_res$`Pr(>F)`
  }))
```

### This contains the F-score test of the anova applied to the mixed-effects model

```{r, eval=F}
degs <- test_resuls %>%
  dplyr::select(-value) %>%
  unnest(anova_pval) %>%
  dplyr::select(-model_coefficients)
```

### This containes the t-values and p-values of the fixed effects

```{r, eval=F}
degs_ext <- test_resuls %>%
  dplyr::select(-c("value", "anova_pval")) %>%
  rename(niche = name) %>%
  unnest(model_coefficients) %>%
  dplyr::filter(term == "nichetest_niche",
                name %in% c("t value", "Pr(>|t|)")) %>%
  dplyr::select(-term) %>%
  mutate(name = ifelse(name == "t value", 
                       "t_value", 
                       "pval")) %>%
  pivot_wider(names_from = name, 
              values_from = value) %>%
  ungroup() %>%
  arrange(niche,-t_value)
```

```{r, eval=F, include=F}
saveRDS(degs_ext, file = "./processed_visium/integration/mixed_effects_dea.rds")
```

```{r, include = F}
degs_ext <- readRDS(file = "./processed_visium/integration/mixed_effects_dea.rds")
```

### Sanity check of some of the genes

```{r}
degs <- degs_ext %>%
  group_by(niche) %>%
  slice(1:30) %>%
  pull(gene) %>%
  unique()
```

Let's pick a gene that is highly expressed in the first niche

```{r}
niche_gex_cpm_long %>%
  dplyr::filter(gene == degs[31]) %>%
  #unnest(data) %>%
  ggplot(aes(x = niche, y = expr)) +
  geom_boxplot() +
  ggtitle(degs[31]) +
  theme(axis.text.x = element_text(angle = 90))
```

Now let's see if the PCA improves...

```{r}
ilr_pcs <- prcomp(x = t(std_niche_gex_cpm[degs, -which(meta_data$niche == "niche_8")]),
                  center = T,scale. = T)

ilr_pcs <- ilr_pcs$x %>%
  as.data.frame() %>%
  rownames_to_column("col_id")

ilr_pcs %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = niche)) +
      geom_point(size = 2) +
      theme_classic()
```

```{r}
ilr_pcs <- prcomp(x = t(std_niche_gex_cpm[degs, ]),
                  center = T,scale. = T)

ilr_pcs <- ilr_pcs$x %>%
  as.data.frame() %>%
  rownames_to_column("col_id")

ilr_pcs %>%
  left_join(meta_data, by = "col_id") %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = niche)) +
      geom_point(size = 2) +
      theme_classic()
```

Let's plot marker genes

```{r, fig.height=10, fig.width=8}
sign_genes <- degs_ext %>%
  dplyr::arrange(niche, pval) %>%
  group_by(niche) %>%
  dplyr::mutate(pval_adj = p.adjust(pval)) %>%
  dplyr::filter(t_value > 0, pval_adj < 0.25) %>%
  dplyr::slice(1:10) %>%
  pull(gene) %>%
  unique()
  
red_degs_ext <- degs_ext %>% 
  dplyr::filter(gene %in% sign_genes) %>%
  dplyr::select(niche, gene, t_value) %>%
  pivot_wider(names_from = gene, values_from = t_value) %>%
  column_to_rownames("niche") %>%
  as.matrix()

draw(Heatmap(t(scale(red_degs_ext)),
        row_names_gp = gpar(fontsize = 5),
        row_dend_side = "left",
        heatmap_legend_param = list(direction = "horizontal")),
     heatmap_legend_side = "bottom", 
     annotation_legend_side = "bottom")
```

This is the proper restrictive way of doing this. But let's do some flexible analysis for the sake of 

```{r, fig.height=15, fig.width=8}
sign_genes <- degs_ext %>%
  dplyr::arrange(niche, -t_value) %>%
  group_by(niche) %>%
  dplyr::filter(t_value > 0, pval < 0.05) %>%
  dplyr::slice(1:10) %>%
  pull(gene) %>%
  unique()
  
red_degs_ext <- degs_ext %>% 
  dplyr::filter(gene %in% sign_genes) %>%
  dplyr::select(niche, gene, t_value) %>%
  pivot_wider(names_from = gene, values_from = t_value) %>%
  column_to_rownames("niche") %>%
  as.matrix()

draw(Heatmap(t(scale(red_degs_ext)),
        row_names_gp = gpar(fontsize = 5),
        row_dend_side = "left",
        heatmap_legend_param = list(direction = "horizontal")),
     heatmap_legend_side = "bottom", 
     annotation_legend_side = "bottom")

```


# GSEA

Can we enrich the processes in each niche?

```{r, warning = F}
markers <- readRDS("./markers/Genesets_Dec19.rds")
markers <- markers$MSIGDB_CANONICAL

gsea <- degs_ext %>%
  group_by(niche) %>%
  nest() %>%
  dplyr::mutate(gsea_run = map(data, function(dat) {
    
    gene_ranks <- set_names(dat$t_value, dat$gene)
    
    fgsea(markers, gene_ranks) %>% 
      as.data.frame() %>% 
      dplyr::select(pathway, pval, padj, ES, NES) %>% 
      arrange(abs(NES))
    
  })) %>%
  dplyr::select(gsea_run)
```

### Can we cluster niches based on their functions?

First get the top 15 processes per niche

```{r}
sign_paths <- gsea %>% unnest() %>% 
  filter(padj < 0.25, NES > 0) %>% 
  arrange(niche, padj) %>%
  slice(1:15) %>%
  pull(pathway)

gsea_red_results <- gsea %>% unnest() %>%
  dplyr::filter(pathway %in% sign_paths) %>%
  dplyr::select(niche, pathway, NES) %>%
  #dplyr::mutate(pathway = substr(pathway, 0, 40)) %>%
  pivot_wider(names_from = pathway, values_from = NES) %>%
  column_to_rownames("niche") %>%
  as.matrix()

gsea_red_results[is.na(gsea_red_results)] <- 0

```

```{r, fig.height = 20, fig.width = 15}
draw(Heatmap(t(scale(gsea_red_results)),
        row_names_gp = gpar(fontsize = 7),
        row_dend_side = "left",
        heatmap_legend_param = list(direction = "horizontal")),
     heatmap_legend_side = "bottom", 
     annotation_legend_side = "bottom")
```


