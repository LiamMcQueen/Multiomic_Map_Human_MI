---
title: "Compositional distances of spatial data (niches)"
author: "Ricardo Ramirez"
date: "4/23/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---
## Introduction

One way to compare spatial samples is using their compositional features. In other words, the feature space of each sample is the proportions of each niche (defined using integration methods).

Compositional data is relatively difficult to analyze because proportions are not independent. The space generated by these features is suboptimal for usual analysis such as PCA and linear models.

One option to analyze compositional data is using log-ratio transformations, that allow to send the data into a format suitable for regular statistical analysis

```{r setup, include=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(philentropy)
library(compositions)
library(Seurat)
library(cowplot)
library(ComplexHeatmap)
library(uwot)
```

## Analyzing compositions from a single cell atlas

Load annotations of visium samples

```{r}
sample_dict <- read.table("./markers/visium_annotations.txt",
                                   sep = "\t", header = T)

sample_dict
```

Load all of the data and visualize the proportions

```{r}
# Get atlas cell-info ------------------------------------------------------------------------------------
atlas_meta <- readRDS("./processed_visium/integration/ps_integrated_slides.rds")[[1]][["annotations"]]

# Cell-type composition -----------------------------------
cell_info <- atlas_meta %>%
  dplyr::group_by(orig.ident, opt_clust_integrated) %>%
  summarize(ncells = length(opt_clust_integrated)) %>%
  dplyr::mutate(all_sample_cells = sum(ncells)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(cell_prop = ncells/all_sample_cells) %>%
  left_join(sample_dict, by = c("orig.ident" = "sample_id")) %>%
  mutate(patient_sample = paste0(patient, "_", region))

head(cell_info)
```

```{r}
cell_info %>%
  ggplot(aes(x = ncells,
           y = patient_sample,
           fill = opt_clust_integrated)) + 
  geom_bar(position="fill", 
           stat="identity") +
  theme(legend.position = "bottom") +
  ylab("") + xlab("n_spots")  
```

### How similar are the niche compositions between patients?

First lets ensure that all proportions are complete. This means that the sum of all compositions equal to 1 per sample.

In this case we have 28 samples and 23 niches

```{r}
cell_props <- cell_info %>%
  dplyr::select(orig.ident, opt_clust_integrated, cell_prop) %>%
  pivot_wider(values_from = cell_prop,
              names_from = opt_clust_integrated) %>%
  column_to_rownames(var = "orig.ident") %>%
  acomp() %>%
  as.data.frame()

cell_props[is.na(cell_props)] <- 0

head(cell_props)

dim(cell_props)

cell_props <- cell_props[sample_dict$sample_id,]
rownames(cell_props) <- paste0(sample_dict$region, "_", sample_dict$sample_id)
```

Not all niches are informative

```{r}
ComplexHeatmap::Heatmap(cell_props)
```

So let's cut all the niches that aren't particularly present in 25% of samples

```{r}
niche_filter <- colSums(cell_props > 0.01)/nrow(cell_props) > 0.25
cell_props <- cell_props[, niche_filter]

ComplexHeatmap::Heatmap(cell_props)
```

```{r}
# Trick to go back to original names
rownames(cell_props) <- sample_dict$sample_id

comp_pca_res <- prcomp(x = cell_props)
comp_pcs <- comp_pca_res$x %>%
  as.data.frame() %>%
  rownames_to_column("orig.ident")
```

```{r}
comp_pcs %>%
left_join(sample_dict, by = c("orig.ident" = "sample_id")) %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = serial_number, 
             label = region)) +
      geom_point(size = 1) +
      ggrepel::geom_text_repel() +
      theme_classic()
```


Then let's transform this data using isometric log ratios since they are better than raw proportions:

1) Get the transformation base

Each of the columns represents the weights of the orthonormal basis. This basis is formed by cell_types-1, since you only need n-1 elements to build ratios. (eg, you always know the last element of a series of proportions since everything must sum 1)

```{r}
baseILR <- ilrBase(x=acomp(cell_props),
                  method = "basic")

head(baseILR)
```

Let's not think too much on the weights now but check the appendix if interested

```{r}
#ILR transformation
cell_ilr <- as.matrix(ilr(as.matrix(cell_props), baseILR))
colnames(cell_ilr) <- paste0("ILR_", 1:ncol(cell_ilr))
cell_ilr
```

This features capture all the information of compositions in an orthonormal space that allow us to do regular analysis.

### PCA

For this project I am interested in knowing which patients look similar when looking only at compositions

```{r}
ilr_pcs <- prcomp(x = cell_ilr)
ilr_pcs <- ilr_pcs$x %>%
  as.data.frame() %>%
  rownames_to_column("orig.ident")
```

```{r}
ilr_pcs %>%
  left_join(sample_dict, by = c("orig.ident" = "sample_id")) %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = serial_number, 
             label = region)) +
      geom_point(size = 1) +
      ggrepel::geom_text_repel() +
      theme_classic()
```

### UMAP

```{r}
gex_umap <- umap(cell_ilr, 
                 n_neighbors = 7, 
                 learning_rate = 0.5, 
                 init = "random") %>%
  as.data.frame() %>%
  mutate(orig.ident = rownames(cell_ilr)) %>%
  left_join(sample_dict, by = c("orig.ident" = "sample_id")) %>%
  ggplot(aes(x = V1, y = V2, 
             color = serial_number, 
             label = region)) +
      geom_point(size = 1) +
      ggrepel::geom_text_repel() +
      theme_classic() +
  xlab("UMAP1") +
  ylab("UMAP2")

print(gex_umap)

```

### Contrast to usual methods

One could argue that using counts is also possible with information metrics. Let's use Jensen-Shannon divergence distances to do the same

```{r}
cell_counts <- cell_info %>%
  dplyr::select(orig.ident, opt_clust_integrated, ncells) %>%
  dplyr::filter(opt_clust_integrated %in% colnames(cell_props)) %>%
  pivot_wider(values_from = ncells,
              names_from = opt_clust_integrated) %>%
  column_to_rownames(var = "orig.ident") %>%
  as.matrix()

cell_counts[is.na(cell_counts)] <- 0

print(cell_counts)

jsd_dist <- as.data.frame(philentropy::JSD(cell_counts,
                                           est.prob = "empirical"))
  
rownames(jsd_dist) = colnames(jsd_dist) <- rownames(cell_counts) 
  
# Make it distance ----------------------------------
jsd_dist <- jsd_dist ** (1/2)

mds_data <- cmdscale(dist(jsd_dist), eig=TRUE, k=2)$points

mds_data %>%
  as.data.frame() %>%
    rownames_to_column("orig.ident") %>% 
left_join(sample_dict, by = c("orig.ident" = "sample_id")) %>%
  ggplot(aes(x = V1, y = V2, 
             color = serial_number, 
             label = region)) +
      geom_point(size = 1) +
      ggrepel::geom_text_repel() +
      theme_classic()
```
