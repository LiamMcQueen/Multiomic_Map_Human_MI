---
title: "Compositional distances"
author: "Ricardo Ramirez"
date: "4/15/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Introduction

One way to compare single cell samples is using their compositional features. In other words, the feature space of each sample is the cell proportions of each cell-type.

Compositional data is relatively difficult to analyze because proportions are not independent. The space generated by these features is suboptimal for usual analysis such as PCA and linear models.

One option to analyze compositional data is using log-ratio transformations, that allow to send the data into a format suitable for regular statistical analysis

```{r setup, include=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(philentropy)
library(compositions)
```

## Analyzing compositions from a single cell atlas

First load all of the data and visualize the proportions

```{r}
# Get atlas cell-info ------------------------------------------------------------------------------------
atlas_meta <- readRDS("./visium_results_manuscript/integration/ps_patients_ct.rds")[[1]][["annotations"]]

# Cell-type composition -----------------------------------
cell_info <- atlas_meta %>%
  group_by(orig.ident, cell_type) %>%
  summarize(ncells = length(cell_type)) %>%
  dplyr::mutate(all_sample_cells = sum(ncells)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(cell_prop = ncells/all_sample_cells)

head(cell_info)
```

```{r}
cell_info %>%
  ggplot(aes(x = ncells,
           y = orig.ident,
           fill = cell_type)) + 
  geom_bar(position="fill", 
           stat="identity") +
  theme(legend.position = "bottom") +
  ylab("") + xlab("n_cells")  
```

### How similar are the cell-type compositions between patients?

First lets ensure that all proportions are complete. This means that the sum of all compositions equal to 1 per sample.

In this case we have 7 samples and 9 cell-types

```{r}
cell_props <- cell_info %>%
  dplyr::select(orig.ident, cell_type, cell_prop) %>%
  pivot_wider(values_from = cell_prop,
              names_from = cell_type) %>%
  column_to_rownames(var = "orig.ident") %>%
  acomp() %>%
  as.data.frame()

head(cell_props)

dim(cell_props)
```

Then let's transform this data using isometric log ratios:

1) Get the transformation base

Each of the columns represents the weights of the orthonormal basis. This basis is formed by cell_types-1, since you only need n-1 elements to build ratios. (eg, you always know the last element of a series of proportions since everything must sum 1)

```{r}
baseILR <- ilrBase(x=cell_props,
                  method = "basic")

head(baseILR)
```

Let's not think too much on the weights now but check the appendix if interested

```{r}
#ILR transformation
cell_ilr <- as.matrix(ilr(as.matrix(cell_props), baseILR))
colnames(cell_ilr) <- paste0("ILR_", 1:ncol(cell_ilr))
cell_ilr
```

This features capture all the information of compositions in an orthonormal space that allow us to do regular analysis.

### PCA

For this project I am interested in knowing which patients look similar when looking only at compositions

```{r}
ilr_pcs <- prcomp(x = cell_ilr)
ilr_pcs <- ilr_pcs$x %>%
  as.data.frame() %>%
  rownames_to_column("orig.ident")
```

Adding annotations

```{r}
sample_dict <- read.table("./markers/NEW_PatIDs_visium_overview_allsamples.tsv",
                                   sep = "\t", header = T) %>%
  mutate_all(as.character) %>%
  dplyr::select(snRNA, New.Ids) %>%
  dplyr::rename(orig.ident = snRNA,
                patient_sample = New.Ids) %>%
  dplyr::mutate(patient = map_chr(strsplit(patient_sample, "_"), 
                                  ~.x[[1]]),
                area = map_chr(strsplit(patient_sample, "_"), 
                               ~.x[[2]]))
```

```{r}
sample_dict
```


```{r}
ilr_pcs %>%
  left_join(sample_dict) %>%
  ggplot(aes(x = PC1, y = PC2, 
             color = area, 
             label = patient)) +
      geom_point(size = 1) +
      ggrepel::geom_text_repel() +
      theme_classic()
```

### Multidimensional scaling

Alternatively you can calculate distances using the ILR coordinates and send them into an mds. (It will be very similar)

```{r}
mds_data <- cmdscale(dist(cell_ilr), eig=TRUE, k=2)$points

mds_data %>%
  as.data.frame() %>%
    rownames_to_column("orig.ident") %>% 
    left_join(sample_dict) %>%
  ggplot(aes(x = V1, y = V2, 
             color = area, 
             label = patient)) +
      geom_point(size = 1) +
      ggrepel::geom_text_repel() +
      theme_classic()

```

### Contrast to usual methods

One could argue that using counts is also possible with information metrics. Let's use Jensen-Shannon divergence distances to do the same

```{r}
cell_counts <- cell_info %>%
  dplyr::select(orig.ident, cell_type, ncells) %>%
  pivot_wider(values_from = ncells,
              names_from = cell_type) %>%
  column_to_rownames(var = "orig.ident") %>%
  as.matrix()

jsd_dist <- as.data.frame(philentropy::JSD(cell_counts,
                                           est.prob = "empirical"))
  
rownames(jsd_dist) = colnames(jsd_dist) <- rownames(cell_counts) 
  
# Make it distance ----------------------------------
jsd_dist <- jsd_dist ** (1/2)

mds_data <- cmdscale(dist(jsd_dist), eig=TRUE, k=2)$points

mds_data %>%
  as.data.frame() %>%
    rownames_to_column("orig.ident") %>% 
    left_join(sample_dict) %>%
  ggplot(aes(x = V1, y = V2, 
             color = area, 
             label = patient)) +
      geom_point(size = 1) +
      ggrepel::geom_text_repel() +
      theme_classic()
```


